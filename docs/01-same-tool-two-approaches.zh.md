# 同一个工具，两种做法，代码差在哪

上一个系列里，我让 AI 独立写了 jsbench，然后花了 30 多次重构才把架构理顺。做完之后一直在想：如果一开始就把架构想清楚，再让 AI 写代码，还需要重构吗？

所以我又做了一个项目——jsmock，一个可编程的 HTTP Mock Server。这次先跟 AI 讨论设计，定好分层和模块边界，然后再写代码。

为了比较效果，我同时让 AI 用老方式写了一版——给一份 README，让它自由发挥。两个版本功能一样，技术栈一样（C + QuickJS），唯一的区别是有没有人先定架构。

## "先设计"具体设计了什么

jsbench 那次，给 AI 的是一份 README——产品长什么样、API 怎么用。架构完全交给 AI 自己定。

jsmock 这次，我在写第一行代码之前定了三样东西。

**第一，定了分层和文件清单。** 13 个模块，每个模块的职责写清楚：

| 层 | 文件 | 职责 |
|---|---|---|
| 事件层 | js_epoll / js_timer / js_engine / js_thread | epoll 封装、定时器、事件循环、工作线程 |
| 连接层 | js_conn / js_http | 连接状态机、读写 buffer、HTTP 解析和序列化 |
| 应用层 | js_route / js_store / js_qjs / js_web | 路由匹配、KV 存储、QuickJS 执行、Web API 绑定 |
| 胶水层 | js_runtime / js_main / js_tls | 全局运行时、入口、TLS 预留 |

依赖方向只能往下——应用层可以用连接层的类型，连接层不能碰应用层的东西。

**第二，定了架构决策。** 不是模糊的"用 epoll"，而是具体的约束：

- 多线程，N 个工作线程，每个线程有自己的 epoll + timer
- 线程通过 `__thread` 局部存储访问自己的上下文
- 每个请求创建独立的 JSRuntime + JSContext，处理完就释放
- 依赖链：`js_epoll_t` → `js_timer_t` → `js_engine_t` → `js_thread_t`

还定了启动流程（编译脚本 → 读配置 → 建 listen socket → 起线程）和请求流程（epoll 通知 → 读 buffer → 解析 HTTP → 建 JS 上下文 → 执行 → 写响应 → 释放上下文）。

**第三，定了命名规范。** 所有文件叫 `js_xxx.c` / `js_xxx.h`。所有函数带 `js_` 前缀。C 层类型用 `js_xxx_t`，QuickJS 绑定层用 `JSXxxData`。每个 `.c` 文件只 include 一个中央头文件 `js_main.h`，不直接 include 其他头文件。

这些加起来不到两页纸，跟 jsbench 那次比也没多花多少时间。但 jsbench 事后重构改了 30 多次。提前把骨架定好，后面省掉的工作量远比这两页纸大得多。

对照组 jsmock-ai 拿到的只有一份 README，跟 jsbench 一样：产品描述 + API 示例。架构全凭 AI 自己判断。

## 逐维度评分

| 维度 | jsmock（先设计） | jsmock-ai（AI 自由发挥） | 满分 |
|------|:---:|:---:|:---:|
| 并发架构 | 9 | 3 | 10 |
| 连接管理 | 8 | 4 | 10 |
| 模块化 | 9 | 6 | 10 |
| 类型设计 | 8 | 6 | 10 |
| 可扩展性 | 8 | 4 | 10 |
| HTTP 协议 | 8 | 6 | 10 |
| 健壮性 | 7 | 5 | 10 |
| 可读性 | 7 | 8 | 10 |
| 功能完整度 | 8 | 7 | 10 |
| **总分** | **72** | **49** | **90** |

23 分的差距。但分布跟 jsbench 那次不一样——上次涨的是重构带来的改善，这次从第一天就拉开了。

注意可读性那一行：AI 自由发挥的版本反而更高。5 个文件，1522 行，顺着读就懂了。jsmock 有 26 个文件 2608 行，第一次打开需要理解模块关系。这很正常——架构的代价就是复杂度前置，换来的是长期的可维护性。

## 涨 6 分的并发架构：AI 选最短路径，不是最优路径

这是最大的差距，也是最值得聊的。

AI 自由发挥的版本是单线程阻塞模型——accept 一个连接，读请求，处理，发响应，关连接，再 accept 下一个。同一时刻只能处理一个请求。如果某个客户端网络慢，整个服务器等着它。

jsmock 是多线程 + epoll 事件循环。四个工作线程，每个线程用 `EPOLLEXCLUSIVE` 共享同一个 listen fd，连接非阻塞，数据到了才处理。

AI 不知道 epoll 吗？知道。你问它 mock server 该不该用 epoll，它能分析利弊写一篇文章。但当它自己从零写一个项目的时候，它选了阻塞 accept 循环。

jsbench 那次我就观察到了这个现象：**AI 有知识，但做架构决策的时候，它默认走最短路径。** 不是最优路径，是最短路径——代码最少、概念最少、能跑就行。

这不是 AI 的 bug，是它的工作方式。它在回答问题的时候会权衡各种因素，但在写代码的时候会走阻力最小的方向。如果你没说"要并发"，它就写单线程。如果你没说"连接要有状态"，它就 accept 到 close 一条线走完。

这也是为什么"先设计"有用——不是因为 AI 不会写好代码，是因为有些决策必须在第一行代码之前做出来。一旦选了阻塞模型，后面的 HTTP 解析、连接管理、超时处理全部受限于这个选择。

## 涨 4 分的连接管理：有没有"连接"这个概念

jsmock 里连接是一个有生命周期的对象——有状态（READING → WRITING → CLOSING）、有读写 buffer、有最后活跃时间。它可以在任何阶段暂停，去处理别的连接，回来继续。

jsmock-ai 里没有"连接"这个概念。accept 拿到 fd，阻塞读完，处理完发回去，close。fd 从头用到尾。

这像是个技术细节，但它反映的是一个更深的问题：**AI 不会主动引入一个还不需要的概念。**

连接作为"对象"这个抽象，在单线程阻塞模型里确实不需要——反正同一时刻只有一个连接在处理。AI 不会预见到"如果以后要并发，连接就必须有状态"。它只解决眼前的问题，不为将来留空间。

这跟 jsbench 里 `js_http_peer_t` 的故事一样——AI 不会发现"这里缺一个概念"。它把数据放在最方便的地方。但"方便"和"正确"不是一回事。人的价值在于看到当前不需要、但未来会需要的概念，提前把它定义出来。

## 涨 3 分的模块化：13 个文件 vs 5 个文件

jsmock 的 13 个模块有严格的依赖顺序，通过一个中央头文件 `js_main.h` 定义。底层是 epoll → timer → engine → thread，中间是 conn → http → route，上层是 qjs → web → runtime。每层只依赖下面的层，不知道上面的存在。

jsmock-ai 的 5 个模块——server、engine、router、store、main——各自独立，通过 main.c 串起来。模块之间没有显式的依赖关系。

5 个文件的时候这没什么问题。但模块化不是为了现在好管，是为了以后能长大。如果要加 TLS、WebSocket、中间件，jsmock 的分层已经留好了位置（js_tls.h 是预留的）。jsmock-ai 要加这些，得先把 server.c 里的 socket 代码、HTTP 代码、响应代码拆开——相当于重构。

这也呼应了 jsbench 系列的结论：**AI 擅长写"现在就够用"的代码，但不会为"以后可能需要"做设计。** 分层、预留接口、管理依赖方向——这些都是对未来的投资。AI 不做投资。

## 两个版本得分一样的地方

路由匹配，两版几乎一样——按 `/` 分段，`:param` 捕获参数，逐段比较。135 行 vs 124 行，思路完全相同。

KV 存储也是，都用 DJB2 哈希 + 链表。jsmock 多了 mutex 锁（因为多线程），jsmock-ai 单线程所以不需要。

命名、错误处理、内存管理，两版都做得不错。

规律很清楚：**规则明确的模块，有没有人设计差别不大。** 路由匹配有明确的规范（HTTP method + path pattern），KV 存储是经典数据结构，这些 AI 自己就能做好。

差距只出现在需要做架构判断的地方——并发模型、连接抽象、模块分层、依赖方向。这些没有标准答案，需要根据场景权衡。

## 和 jsbench 的对比：先设计 vs 事后重构

jsbench 系列的故事是：AI 写了 59 分的代码，我通过 30 多次重构改到了 85 分。

jsmock 的故事是：先设计好架构再让 AI 写，第一版就是 72 分。

两个数字放在一起看：

| | AI 自由发挥 | 事后重构 | 先设计后实现 |
|---|:---:|:---:|:---:|
| jsbench | 59 | 85 | — |
| jsmock | 49 | — | 72 |

先设计的好处：不需要 30 多次重构，不需要推翻方案重来，不需要事后发现"整个 I/O 模型就不对"。给对方向，AI 从第一天写出来的代码就是可以长期维护的。

但也有一个值得注意的地方：jsbench 重构后的 85 分高于 jsmock 的 72 分。这是因为 jsbench 经过了反复迭代——每次重构都加深了对项目的理解，理解又反过来推动更好的设计。先设计省了重构的成本，但也少了"在真实代码里发现新问题"的过程。

最理想的方式可能是两者结合：先设计一个合理的架构，写出来之后再根据实际情况迭代。jsmock 后面的文章会记录这个过程。

## 给想用 AI 做项目的人

这次实验最大的收获：

**架构决策提前做，效率高很多。** 并发模型、连接管理方式、模块分层——这些选了就很难改。如果你让 AI 先写了一个阻塞模型的服务器，后面想改成事件驱动，基本等于重写。但如果你先说"用 epoll，非阻塞，多线程"，AI 就会按这个方向把每一行代码写对。

**不需要设计所有细节。** 我跟 AI 讨论的不是"这个函数怎么写"，而是"有哪些模块、谁依赖谁、连接的状态怎么流转"。这些大方向定了，具体实现 AI 自己就能做。路由匹配怎么写、HTTP 怎么解析——这些不需要人操心。

**判断哪些决策需要你做，哪些交给 AI。** 规则明确的事（路由、存储、解析）交给 AI。需要权衡的事（并发模型、分层、预留什么接口）自己做。分清这两类，是用好 AI 的关键。

下一篇讲设计阶段的具体过程——我和 AI 讨论了什么，哪些判断是我做的，哪些是 AI 提出的。

---

专栏：[我带 AI 写了个项目](https://www.zhihu.com/column/c_2006330352843657698)

GitHub: https://github.com/hongzhidao/jsmock
