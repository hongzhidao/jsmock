# 3句话带 AI 做了一次解耦

上一篇搬完 handlers，js_conn.c 的结构看着合理了——listen/accept、连接创建/读写/关闭、事件回调，连接相关的代码终于住在一起。

但打开 `js_conn_on_read`，里面在调 `js_http_parse_request`、`js_qjs_handle_request`、`js_http_serialize_response`。conn 是连接层，它认识 HTTP 解析，认识 JS 执行，认识响应序列化。底层不该认识上层，依赖方向反了。

上一篇的判断标准是"代码操作的对象属于谁"——handlers 操作连接的读写和生命周期，归 conn 没问题。但还有一个标准没用到：代码需要的知识属于哪一层。`js_conn_on_read` 操作的是连接，但它需要知道 HTTP 请求怎么解析、JS 脚本怎么执行、HTTP 响应怎么序列化。这些知识全在 conn 的上层。

搬代码没解决这个问题。handlers 从 engine 搬到 conn，依赖关系原封不动地跟着搬了过来。

## 对话第1轮：跟 AI 说解耦，它一股脑全搬走了

跟 AI 说了一句话：conn 和 http 耦合在一起了，改进下架构，conn 在 http 的更底层。

AI 读完相关代码，方案很快：把 `js_listen_accept`、`js_conn_on_read`、`js_conn_on_write` 全部从 js_conn.c 搬到 js_http.c，重命名成 `js_http_accept`、`js_http_listen_start`。

看到这个方案的第一反应是有点哭笑不得。我说 conn 不该认识 HTTP，它就把所有东西一股脑搬到 HTTP 去了——好像跟人说"别往左走"，它就直接往右拐，没想过最合适的方向在哪。

accept 是 listen socket 上的操作：接受 TCP 连接、设置 fd 属性、分配连接结构体。这是 TCP 层的事，跟 HTTP 没关系。不管上面跑的是 HTTP 还是 WebSocket，accept 的逻辑完全一样。AI 把"和 HTTP 一起出现的代码"当成了"属于 HTTP 的代码"——按共现关系分类，不是按语义分类。它理解了"解耦"这个目标，但分不清具体哪些逻辑属于哪一层。

## 对话第2轮：一句话纠正，这次像样了

一句话：accept 行为应该属于 listen，listen 现在属于 conn。

AI 立刻理解了，不需要再解释为什么。修正后的方案：accept 留在 js_conn.c，问题出在 `js_listen_accept` 里硬编码了 HTTP handler。改法是在 `js_listen_t` 上加两个函数指针 `on_conn_read` 和 `on_conn_write`，`js_listen_start` 接受这两个参数，accept 的时候用传进来的 handler 而不是硬编码的。

这次的感觉不一样了。一句话纠正，它不用多问就调整到位，方向对了，细节也能自己补全。conn 层确实不再直接引用 HTTP 的函数，解耦目标达到了。不过传两个裸 handler 不够干净——上层协议的初始化被拆散了。以后连接初始化还要设置其他东西——超时、buffer 大小、协议状态——参数列表会不断膨胀。AI 停在了"解决当前问题"这一步，没再往前想一步。

## 对话第3轮：给了个思路，这次满意了

跟 AI 说：在 js_listen_t 增加一个 init conn 这样的 hook。

AI 拿到这个提示，马上就认同了。不是勉强接受，是真的理解为什么一个回调比两个参数好——一个 `on_conn_init` 回调替代两个参数，上层协议实现一个初始化函数，accept 之后调这个函数，连接怎么初始化完全由上层决定。conn 只知道"有个函数要调"，不知道里面干了什么。完整的结构体定义、函数签名、改动文件清单，一次性给出来。

让我比较满意的是 AI 提取出了 `js_listen_t` 这个结构体。之前 listen 就是一个裸的 `js_event_t`，没有自己的身份。AI 把 event 和回调包进一个独立的类型里，listen 从"event 的一种用法"变成了一个有名字、有职责的领域概念。领域建模是架构设计里比较难的部分，需要对业务有理解才能判断什么东西值得独立成一个概念。AI 在这一步做得不错。

```c
typedef void (*js_conn_init_t)(js_conn_t *conn);

typedef struct {
    js_event_t      event;
    js_conn_init_t  on_conn_init;
} js_listen_t;
```

js_http.c 里实现 `js_http_conn_init`，把 read/write handler 设成 HTTP 的处理函数。js_thread.c 启动 listen 的时候传这个函数进去。conn 对 HTTP 零感知，HTTP 通过一个 hook 控制连接的行为。以后加 WebSocket，写一个 `js_ws_conn_init`，conn 一行不用改。

回调是这篇和前两篇手段上的区别。前两篇改架构靠搬代码——函数从一个文件移到另一个文件，改个名字。这篇光搬不够，得引入新的接口让底层在不认识上层的前提下把控制权交出去。

## 对话第4轮：方案定了，AI 一分钟改完

方案确定了，把最终设计贴给 AI，说 implement。

接下来的事情发生得很快。AI 读了 7 个文件理解上下文，改了 6 个文件，编译零警告，54 个测试全过。没有返工，没有追问，一轮结束。前面三轮设计来回花了大部分时间，真正动手改代码，不到一分钟。

js_conn.c 干净了。listen/accept 处理 TCP 连接的建立，conn 管生命周期和通用读写，没有 HTTP 的痕迹。HTTP 请求解析、JS 执行、响应序列化全在 js_http.c，通过 `js_http_conn_init` 这一个 hook 接入连接层。依赖方向也理顺了：js_http 依赖 js_conn（调 conn_read、conn_write、conn_close），js_conn 不知道 js_http 的存在。上层依赖下层，下层通过回调把控制权交给上层。

把整个过程和结果画出来，不看代码也能理解发生了什么：

```
人                                AI
│                                 │
├─ "conn和http耦合了，解耦"  ───→  ├─ 方案1：全搬到HTTP        ✗
│                                 │  把TCP代码搬到了HTTP层
│                                 │
├─ "accept属于conn"          ───→  ├─ 方案2：传两个函数指针     △
│                                 │  能用，但接口会膨胀
│                                 │
├─ "加一个init回调"          ───→  ├─ 方案3：一个回调搞定       ✓
│                                 │  还提取了新的领域概念
│                                 │
├─ "执行"                   ───→  ├─ 改6个文件，1分钟完成      ✓
│                                 │  编译通过，54个测试全过
```

```
    解耦前                        解耦后

  ┌────────┐                   ┌────────┐
  │  conn  │                   │  conn  │
  │ (连接层) │                   │ (连接层) │
  └────────┘                   └────────┘
       │                           ↑
       │ conn 直接调用               │ HTTP 通过回调接入
       │ HTTP 的函数                 │
       ↓                           │
  ┌────────┐                   ┌────────┐
  │  HTTP  │                   │  HTTP  │
  └────────┘                   └────────┘

  底层认识上层 ✗                底层不认识上层 ✓
  加协议要改conn                加协议conn不用动
```

## 3 句话和 3 轮

回头看整个过程，人的输入是 3 句话——识别耦合、纠正分层、给出抽象。AI 读了全部代码，写了 3 版方案，最终改 6 个文件。

三轮下来，对 AI 的设计能力有了更具体的认识。它不是没有设计能力——第一轮就理解了解耦的目标，方案有方向；第二轮人纠正一句，它立刻调整，不是从头来过。但关键节点上的判断——accept 归哪一层、两个参数和一个 hook 哪个更好——目前还是人在做。这些判断决定了方案从"能用"到"好用"的距离。而方案一旦确定，AI 的执行力不用怀疑，6 个文件改完、编译、54 个测试，一分钟内结束。

不过让我印象更深的不是速度，是准确率。6 个文件的改动环环相扣——结构体定义改了，所有用到的地方都要跟着改，函数签名变了，调用方的参数要对上，头文件的依赖关系要理清。这些它一次全做对了，没有遗漏，没有手滑。以前自己做这种跨文件重构，总得编译几轮才能把漏掉的地方补上。AI 在这种"已知规则、完整上下文"的任务上，执行精度已经超过人了。

人的优势在另一个维度。3 句话看着轻描淡写，但每句背后是一个判断：什么是问题、问题出在哪一层、用什么手段解决。这种判断不是分析代码能得出的——AI 可以看出 conn 调了 HTTP 的函数，但它看不出这个调用"不该存在"。"不该"是一个设计判断，不是代码事实。判断力来自对系统整体的理解和对未来演化的预期，这目前还是人在提供。

设计花了大部分时间，执行只花了最后一分钟。现在最高效的协作方式就是这样——人在判断点上介入，其余交给 AI。不是谁强谁弱，是各自擅长的东西不一样。

前两篇改架构靠搬代码，这篇靠改接口。封装是把复杂度藏起来，职责是把代码放对地方，解耦是让模块之间不该有的依赖断掉。三个概念解决不同层面的问题，手段也逐步升级——从移动代码到引入回调。下一篇接着改。

代码变更: [09a81cc](https://github.com/hongzhidao/jsmock/commit/09a81cc)

---

专栏：[我带 AI 写了个项目](https://www.zhihu.com/column/c_2006330352843657698)

GitHub: https://github.com/hongzhidao/jsmock
