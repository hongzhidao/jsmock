# 架构是怎么一行一行变烂的

上一篇解耦了 conn 和 HTTP——`on_conn_init` 回调让 conn 层把初始化权交给协议层，自己不再认识 HTTP。架构边界建起来了。

但打开 `js_listen_accept`，看最后两行：

```c
ls->on_conn_init(conn);
js_epoll_add(&eng->epoll, fd, EPOLLIN, &conn->event);
```

第一行调回调，把连接交给协议层。第二行注册 EPOLLIN，让连接开始接收数据。

能跑，测试全过。但 `on_conn_init` 的语义是"这个连接交给你了"。既然交给协议层了，"什么时候开始收数据"也该协议层决定。conn 层在回调之后又替协议层注册了事件——说是交出去了，实际还插了一手。

这不是 bug，不影响功能。但这一行放错了位置。

## 当下看不出区别，代价在后面

看 NBA 比赛，两支球队天赋差不多，最后赢的往往是细节处理更好的那支。失误少两三个，篮板卡位到位，战术执行不走形——每个细节单独看不决定胜负，但四十八分钟累积下来，比分就是这么拉开的。

打台球，球进袋了，母球停在哪？业余选手进球就高兴了。职业选手每一杆都在控制母球走位：这球打完，母球要停在下一球的最佳击打位置。走位差一点，下一球勉强够到；再差一点，只能防守了。一个走位没处理好，不是丢这一球，是后面整盘被动。处理好了，连续几球行云流水，每一杆打完都是好位置。

下象棋，马在这格和旁边那格都能跳，但一个位置同时看住两条线，另一个只看住一条。差一格，十步之后一边攻守兼备，一边顾此失彼。

共同点：**当下看不出区别，代价在后面显现，而且逐步放大。**

回到代码。`js_epoll_add` 留在 conn 层，现在跑 HTTP 没问题。以后加 TLS——accept 之后要先握手再读 HTTP，但 conn 层已经注册了 EPOLLIN，你得先撤掉它做的事再重来。加 WebSocket 也一样，初始化流程不同，conn 层的假设全是错的。每加一个协议，都要绕过 conn 层这行多余的代码。

一行放错位置，后面每次扩展都多一道坎。

## 代码的熵增

物理学有个概念叫熵增——系统自然趋向无序，不需要谁犯大错，不施加外力，有序就会逐渐瓦解。

代码也一样。前两篇花了力气建架构——定分层，建边界。但架构不会自己保持有序。每一次"差不多就行"——一行代码放在能用而不是对的位置——就是一次微小的熵增。一次看不出来。十次之后边界模糊，二十次之后层与层又耦合回去。最后有人说"这代码得重构了"——架构不是突然变烂的，是一行一行变烂的。

重构是熵增到一定程度的大修。这篇做的事不是重构——架构还没乱——是在熵增刚冒头的时候把它按住。

**架构是设计出来的，也是一行一行守出来的。** 设计决定起点，细节决定它能撑多久。

## 改动

跟 AI 说了一句：把 `js_listen_accept` 最后一行 `js_epoll_add` 移到 `js_http_conn_init` 里。

AI 的第一反应是加一层封装——在 conn 层包一个 `js_conn_start` 函数，让协议层调这个函数来注册事件。理由是"HTTP 层不该直接操作 epoll"。

听着有道理，但想多了。conn 层 accept 之后把连接交给协议层，协议层要用这个连接，自然要 enable EPOLLIN——这就是一个直接的动作，不需要再包一层。过度封装本身也是一种细节没处理好：把简单的事搞复杂了。

改完之后，conn 层：

```c
static void js_listen_accept(js_event_t *ev) {
    js_listen_t *ls = js_event_data(ev, js_listen_t, event);
    struct sockaddr_in addr;
    socklen_t addrlen = sizeof(addr);
    int fd = accept4(ev->fd, (struct sockaddr *)&addr, &addrlen,
                     SOCK_NONBLOCK | SOCK_CLOEXEC);
    if (fd < 0)
        return;

    js_conn_t *conn = js_conn_create(fd);
    if (!conn) {
        close(fd);
        return;
    }

    ls->on_conn_init(conn);
}
```

不再需要 `eng`，不再替上层做决定。accept → 创建连接 → 交出去，完了。

协议层：

```c
void js_http_conn_init(js_conn_t *conn) {
    js_engine_t *eng = &js_thread_current->engine;
    conn->event.read  = js_http_on_read;
    conn->event.write = js_http_on_write;
    js_epoll_add(&eng->epoll, conn->event.fd, EPOLLIN, &conn->event);
}
```

设 handler、注册事件，一个函数里完成。以后加 WebSocket，写一个 `js_ws_conn_init`，conn 层不用动。

一行代码换个位置。编译通过，54 个测试全过。

## 为什么 AI 不会主动做这件事

前几篇的改动都有明显的问题——engine 文件太大了、conn 里调了 HTTP 的函数。问题摆在面前，AI 能看出来，也能执行得很好。

这一篇不一样。代码能跑，测试全过，没有症状。`js_epoll_add` 在 `js_listen_accept` 里活得好好的，不报错，不影响性能。AI 看这段代码，不会觉得有什么需要改的。

"这行不该在这里"是一个设计判断，不是代码事实。它来自对边界语义的理解——`on_conn_init` 意味着"交出去"，那交出去之后就不该再插手。这种判断靠的不是代码分析，是对"什么是干净的边界"的品味。品味来自经验，来自踩过的坑，来自对未来演化的预期。

前几篇说的是：人做判断，AI 做执行。这篇补一个角度——**有些判断不是在问题出现时做的，是在问题出现之前做的。** 防火比救火难，因为一切看起来都正常，你要从正常里看出那一点不对。

## 不是每个细节都要死磕

说到这里可能有人会想：一行代码都要纠结，这也太累了。

确实不是每个细节都值得处理。细节有影响范围的区别。变量命名不够好、注释少了一行、代码格式不统一——这些是局部细节，影响的是当前这几行代码的可读性，改不改都行。但 `js_listen_accept` 里那行 `js_epoll_add`，影响的是 conn 和协议层之间的边界定义——以后每加一个协议都会碰到这道坎。这是架构级的细节，值得处理。

区分这两种细节，本身就是一种专业能力。

nginx 的代码就是一行一行 review 出来的。每个 patch 都经过核心团队逐行审查，不是看功能对不对——功能对是基本要求——是看这行代码放在这里，依赖方向对不对，语义清不清楚，以后改起来会不会别扭。nginx 能跑二十年还改得动，不是因为最初设计多完美，是因为每一次提交都有人在守这些细节。

但 nginx 是基础设施，对稳定性和可维护性的要求极高，投入这个精力值得。不是每个项目都需要这样。一个内部工具、一个快速验证的原型，细节处理的标准可以不一样。团队的人力、项目的生命周期、软件的质量要求——这些都影响你在细节上投入多少。

AI 时代这个问题更现实。代码产出的速度快了很多倍，不可能每一行都像 nginx 那样 review。但这不意味着细节判断力不重要——恰恰相反，**你得更快地识别出哪些细节关键、哪些可以放过。** 产出速度越快，筛选能力越重要。

专业的程序员都有这个能力：看一段代码，能分辨出"这里不太好但无所谓"和"这里不对，会留坑"。这种判断力不会因为 AI 写代码而过时，反而因为代码量更大而更值钱。

## 判断力从哪来

这种"看一眼就知道对不对"的能力不是天生的，也不是看几篇文章就能有的。我自己的体会，三件事最有用。

**读优秀的代码。** nginx、Redis、SQLite——这些项目活了十几二十年，经历了无数次迭代还改得动，不是偶然的。读它们的代码，你会看到每一个结构体为什么这样定义，每一层的边界为什么画在这里，每一个回调为什么存在。看多了好代码，再看到不好的代码时，不需要分析就能感觉到"这里不对"——是审美在起作用，而审美是被好作品训练出来的。

**在优秀的代码上加功能。** 光读不够，得动手。给 nginx 写一个模块，给 Redis 加一个命令，在已有的架构上做扩展。你会发现好的架构是有引力的——它会把你的代码引导到正确的位置，加一个功能不需要动已有的结构。而如果你写着写着发现要到处改，要么是你的方向不对，要么是你对这个架构的理解还不够。这种"被好架构纠正"的体验，比看十篇架构文章都管用。

**跟专业的人交流。** 自己读加自己写，进步是有的，但有些东西你看不见——不是能力问题，是视角问题。跟专业的人交流能打破这个盲区。code review 的时候，你觉得没问题的代码，对方指出"这行不该在这里"——你不理解为什么，问了，听了解释，那个"为什么"就变成了你判断力的一部分。这种学习效率最高，因为它精确地作用在你当前认知的边界上。

这三件事没有捷径，是个漫长的过程。但 AI 时代给了一个加速通道：你可以用 AI 快速搭出一个系统，然后自己 review 它、重构它。以前写一个项目要几周，现在几天就能有一个可以拿来练手的代码库。实践的机会多了，学的也更快了。

这篇想说的就一件事：细节很容易被忽略。代码能跑、测试全过、功能没问题——在这种情况下，大部分人不会再多看一眼。但架构就是在这些"没人多看一眼"的地方，一行一行变烂的。

前三篇改架构，搬代码、改接口，改动都不小，问题也比较明显。这篇只有几行代码，改动就一行，反而更能说明细节是什么——不是大的重构，不是新的设计，就是一行代码该在哪。越小的东西越容易忽略，越容易忽略的东西越需要有人看到。

代码变更: [3c39595](https://github.com/hongzhidao/jsmock/commit/3c39595)

---

专栏：[我带 AI 写了个项目](https://www.zhihu.com/column/c_2006330352843657698)

GitHub: https://github.com/hongzhidao/jsmock
