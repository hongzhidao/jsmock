# 给 AI 一个架构级需求，看它到底什么水平

前五篇，每次改架构都是我在引导——发现问题、纠正方向、给出思路，AI 负责执行。读者看完可能会想：你一直在介入，AI 自己做设计到底行不行？

这篇回答这个问题。模型是 Claude Opus 4.6（目前 Anthropic 最强的模型），不引导，看它自己能做成什么样。

## 一个合理的需求

jsmock 目前只支持同步 JS——handler 返回一个 Response，服务器立刻发回去：

```js
mock.get("/api/user", (req) => {
    return new Response(JSON.stringify({ name: "test" }));
});
```

但 mock server 的典型场景是模拟真实后端。真实后端有网络延迟、有数据库查询、有异步操作。如果 handler 不能异步，这些都模拟不了。

需求很自然：支持 async handler，支持 setTimeout：

```js
mock.get("/api/user", async (req) => {
    await new Promise(resolve => setTimeout(resolve, 200));
    return new Response(JSON.stringify({ name: "test" }));
});
```

用法和标准 JS 一样。前端开发者不需要学新 API，async/await + setTimeout 就能模拟任意延迟。

## 这不是加个 sleep 的事

看到 setTimeout，直觉可能是"加个定时器就行了"。但实际上这是一次架构升级。

jsmock 是 C 写的事件驱动服务器，整个线程靠 epoll 事件循环驱动——**不能阻塞**。如果为了等 setTimeout 到期就 sleep 200ms，这个线程上所有其他连接都得跟着等。

JS handler 返回的是 Promise。C 语言没有 `await`，没办法"等"一个 Promise 完成再继续。

setTimeout 的定时器也不是 JS 自己的——QuickJS 作为嵌入式引擎，没有自带事件循环。这个定时器要接入 C 层的 epoll + 红黑树定时器系统。

等待期间，这条连接不能占着事件循环。定时器到期后，要恢复这条连接、取出 JS 执行结果、发送 HTTP 响应、释放 JS 运行时。

一句话总结：请求的生命周期从**线性的**变成**可中断、可恢复的**。这不是功能补丁，是架构变化。

## 前后对比

之前，请求从头走到尾，一条直线：

```
请求 → 执行 handler → 拿到 Response → 发响应
```

handler 同步返回，调完就有结果。

之后，handler 可能返回一个还没完成的 Promise：

```
请求 → 执行 handler → 返回 Promise
                           │
            ┌──────────────┴──────────────┐
            │ 已完成                       │ 未完成
            ↓                             ↓
      直接取结果                     挂起连接（从 epoll 摘除）
      发响应                         注册定时器
                                     回到事件循环
                                     （继续处理其他请求）
                                          │
                                     定时器到期
                                          │
                                     执行 JS 回调
                                     Promise 完成
                                          │
                                     恢复连接（重新注册 epoll）
                                     发响应，释放 JS 运行时
```

左边是原来的同步路径，右边是新增的异步路径。连接多了一个"挂起"状态，请求的生命周期从直线变成了状态机。

整个过程中事件循环不阻塞。异步请求挂起期间，其他请求照常处理。

## AI 做了什么

跟 AI 说了一句：实现 setTimeout。

没有给设计方案，没有说怎么桥接 C 和 JS 的异步模型，没有画架构图。

AI 实现了。编译通过，测试通过，并发也正常——一个请求 setTimeout 200ms，期间发另一个同步请求，立刻返回，互不影响。

## AI 到底什么水平

Kent Beck 有句话在程序员圈子里流传很广：Make it work, make it right, make it fast——先让它跑起来，再让它正确，最后让它快。三个阶段，要求逐级递进。

为了让不写代码的读者也能跟上，后面我会用"实现"和"架构"来替代"跑起来"和"正确"。这个对应不完全精确——"正确"的含义比"架构"更广——但对于理解 AI 的水平够用了。

### 实现：很强，但不是 100% 可靠

这次 setTimeout 的实现，AI 选择了正确的桥接机制——用 QuickJS 的 Promise API 注册 C 语言回调函数，让 JS 引擎在 Promise 完成时通知 C 层取结果。这是成熟 JS 运行时处理 native async 的标准做法。它还做了一个不错的优化：async 函数如果没有真正的异步操作（比如 async 里直接 return），能识别出来走同步路径，不会无脑进入异步流程。

编译通过，测试通过，并发正确。

值得一提的是，QuickJS 不是 nginx 这种有二十年历史、资料丰富的项目。它相对小众，文档有限，网上能找到的 C 层集成 Promise 的参考很少。AI 在这种新技术上也能找到正确的做法，说明它的能力不只是"背答案"——在训练数据不那么充分的领域，它也能基于对底层原理的理解给出合理的方案。

但"跑起来"不等于"没问题"。同一个项目早期，AI 实现了一个 HTTP fetch 功能，测试全绿，16576 次请求，0 错误。我 review 之后发现：**每一次请求其实都失败了。** 代码把每次调用无条件计入"成功"，测试只检查这个数字。AI 写的代码不检查错误，AI 写的测试不验证错误——它们有一致的盲区，完美地互相配合，制造了"一切正常"的假象。

所以实现这一关，AI 能做到 90 分，但剩下的 10 分需要人来 review。**不 review，你不知道那个"能跑"是真能跑还是看着能跑。**

### 架构：不差，但这恰恰是最难的部分

代码没引入屎山。异步逻辑没有和同步路径搅在一起——同步请求走原来的流程，零额外开销；异步请求走新分支，生命周期清晰。代码不混乱，逻辑容易跟。一个不了解项目的 C 程序员，能读懂这段代码在做什么。

到这里，大部分人会说"这不是挺好的吗"。

但"实现"和"架构"之间的差距，往往不是当下能看出来的，而是在后续加功能的时候才显现——**设计得越好，以后加功能越简单。** 这个系列的第二篇，我们对 engine 做了一次全面升级，其中 timer 的设计是我们引入的，完全替换了 AI 原来的实现——从 timerfd + 链表改成了红黑树 + 回调，从 epoll 的事件源变成 engine 的内部工具。这次 setTimeout 恰恰就建立在那个 timer 系统之上。如果当初没有那次升级，AI 现在的实现要么更复杂，要么根本接不上。

这就是架构的累积效应。前面做对的决策，后面的功能就自然简单。前面凑合的决策，后面每加一个功能都多一道坎。

我在 nginx team，同时参与 njs（nginx 的 JavaScript 模块）的开发工作，njs 去年已经支持了 QuickJS。C 层怎么驱动 JS 异步执行，我在生产环境里做过。凭这个经验看，AI 这次的异步设计，我会用不同的方式处理——不是它做错了，是有更好的组织方式，能让后续的功能扩展更顺畅。

**但关键是：我能基于它改进，不需要推翻重来。** 这是区分"不差"和"不行"的分界线。不行的代码你改不动，只能重写。不差的代码方向没错，在上面调整就行。

### 所以 AI 到底在哪一步

**实现完全胜任，架构不差但有经验的工程师能做得更好。**

说得更直观一点。

实现这一关，相当于你招了一个靠谱的程序员。需求丢过去，不用盯，不用干预，交回来的东西能用、能测、能上线。这个能力在今天已经非常强了。

架构这一关，相当于你招了一个有设计经验的人，知识面甚至比你还广——它读过的代码比任何人都多——但在具体项目里做架构决策时，需要你指导方向。而且它学得很快，你纠正一次，它立刻就能调整到位，不需要反复解释。前几篇的经验都是这样：说一句"accept 属于 conn"，它马上就理解了；给一个"加个 init 回调"的思路，它自己能补全所有细节。

这是我喜欢用 AI 的地方。它不是一个只会听命令的工具，也不是一个什么都不用管的全能选手。它是一个**学习速度极快、执行精度极高、但在架构判断上还需要引导的合作者**。

而且这个"还需要引导"不一定是永远的。看 AI 模型迭代的速度，哪天它在架构设计上也超过大部分工程师，我不会觉得意外。但至少现在，架构这件事还需要人来把关——而架构的价值，是让下一次实现更容易。这是累积效应，也是人在 AI 时代最该做的事。

所以，AI 到底什么水平？

**把事情做出来，哪怕有难度，它都能做得很好。但把事情做漂亮——让它好维护、好扩展、以后改起来不头疼——还需要有经验的人带一下。好在它学得快，点一下就通。**

---

专栏：[我带 AI 写了个项目](https://www.zhihu.com/column/c_2006330352843657698)

GitHub: https://github.com/hongzhidao/jsmock
